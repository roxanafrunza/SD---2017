FRUNZA Roxana - 311CB

In fisierul functiiLDIG.c se gasesc functii de prelucrare a listelor dublu inlantuite, circulare, generice. Am implementat urmatoarele functii:
	a) InsLDI - primeste ca parametru adresa celulei dupa care se face inserarea, elementul de tip void pointer si dimensiunea unui element. Functia intoarce 1 daca inserarea a fost realizata cu succes si 0 in caz contrar. Au trebuit tratate 2 cazuri: lista vida (in care varful listei devine noul element) si lista cu mai multe elemente in care trebuie doar refacute legaturile;
	b) InsInc - similar functiei precendente, doar ca inserarea se face mereu inainte de primul element din lista, adica varful listei devine mereu elementul inserat;
	c) ExistaEl - primeste ca parametru lista, un element de tip void* si o functie de comparare. Parcurgand lista, verificam daca functia de comparare intoarce un numar egal cu 0. In caz afirmativ inseamna ca elementul exista in lista si intoarcem 1. Altfel, intoarcem 0;
	d) ElimLDI - eliminam elementul de la adresa *aL refacand legaturile in lista, eliberand memoria ocupata de informatia din celula (cu ajutorul functiei FreeEl) si celula;
	e) DistrLDI - sterge tot spatiul ocupat de lista primita ca parametru;
	f) AfisareLDI - afiseaza lista primita ca parametru cu ajutorul unei functii de tip TFAfi;
	g) LungimeLDI - parcurge lista si intoarce lungimea acesteia.

In fisierul functiiTH.c sunt functii de prelucrare a tabelei hash care aloca memorie, insereaza ordonat, afiseaza, calculeaza numarul de elemente din tabela sau distrug tabela. Functiile de alocare a memoriei, afisare si eliberare a memoriei sunt cele din laborator. 
Pentru functia care numara cate elemente sunt in tabela hash, parcurgem fiecare lista si adunam la variabila suma lungimea acesteia.
La functia de inserare ordonata, trimitem ca parametru tabela in care se doreste sa se efectueze inserarea, elementul de tip void pointer, dimensiunea unui element si un pointer la o functie de comparare a doua elemente care intoarce int. 
Pentru elementul primit, calculam codul hash si vedem in ce lista trebuie inserat. Verificam daca lista este vida si in caz afirmativ, inseram la inceput folosind functia InsInc. Daca lista are un singur element, verificam daca elementul de inserat trebuie plasat inaintea inceputului (in acest caz folosim din nou functia InsInc) sau dupa (folosim functia InsLDI, care va insera dupa adresa primului element din lista). La inserarea intr-o lista cu mai multe elemente au trebuit tratate urmatoarele cazuri:
	a) Inserare la inceput (folosind functia InsInc);
	b) Inserare dupa primul element (folosind functia InsLDI);
	c) Inserare in interior: in acest caz avem o variabila de tip Adresa Lista (ALDI) cu care parcurgem lista si vedem pozitia in care trebuie inserat folosind functia de comparare primita ca parametru. Dupa ce a fost gasita adresa la care trebuie inserat elementul apelam functia InsLDI.
Returnam rez care este 0 pentru inserare nereusita si 1 pentru inserare reusita.

In fisierul testHash.c sunt implementate functiile ceruta in enuntul temei. Pe langa acestea, am implementat functia hash, functii care afiseaza si elibereaza memorie pentru elementele de tip TKey, si doua functii de comparare : una care ordoneaza elementele descrescator dupa frecventa, si in caz de egalitate, alfabetic, si cea de a doua care verifica daca elementele au acelasi nume.
	Functia SET
Aceasta functie primeste ca parametri doua stringuri, pentru value si key, si tabela hash. Alocam un element in care salvam informatia pentru key si value si a carui frequency este egal cu 0. In cazul in care alocarea a esuat, intoarcem 0. Altfel, calculam indicele in care ar trebui inserat elementul si verificam daca exista deja in lista respectiva. Daca exista, iesim din functie. In caz contrar, vedem daca numarul de elemente din tabela hash este mai mare sau egal cu 2*M. In caz afirmativ, este necesara o realocare a vectorului hash->v la o dimensiune de 2*M. Salvam intr-o variabila auxiliara vectorul, modificam vectorul hash->v, si parcurgem fiecare lista initiala. Luam fiecare element si il inseram ordonat in tabela hash folosind functia InsTHO. La fiecare inserare trebuie verificat daca in lista sunt deja M elemente. Daca acest lucru se intampla, eliminam ultimul element folosind functia ElimLDi.
	Functia GET
Functia primeste ca parametri tabela hash si un string pentru key. Calculam indicele listei in care ar trebuie sa se afle elementul. Daca acesta nu exista, iesim din functie si intoarcem NULL. Altfel cautam celula in care se afla. Salvam informatia intr-un element auxiliar, a carui key si value sunt
aceleasi dar care are frequency incrementat cu 1. Inseram acest element in lista. Dupa aceea cautam vechiul element (care are aceeasi key si value, dar cu frequency mai mic) si il eliminam folosind ElimLDI. Functia intoarce un pointer catre elementul inserat.
	Functia REMOVE
Functia primeste ca parametri tabela hash si un string pentru key. Calculam indicele listei in care ar trebuie sa se afle elementul. Daca acesta nu exista, iesim din functie. Altfel, parcurgem lista si eliminam elementul cand a fost gasit. Avem un caz special, in caz ca elementul este ultimul din lista, deoarece fiind liste circulare la o parcurgere mereu ar fi ramas neverificat fie primul element (daca porneam de la *aL->urm) sau ultimul element (daca pornim de la *aL, varianta pe care am ales-o). Daca lista inainte de eliminare avea un singur element (lungimea = 1) si am sters elementul cautat, transformam lista in lista vida, de aceea i-am dat valoarea NULL.
	Functiile PRINT si PRINT_LIST
Pentru functia print trimitem ca parametru tabela hash si fisierul in care scriem informatia. Parcurgem fiecare lista nevida din vectorul de liste si afisam fiecare element folosind AfiEl. Pentru functia print_list mai primim si un index care trebuie sa fie in intervalul [0,M-1] si afisam lista folosind AfiLDI. Daca lista este vida, afisam un mesaj corespunzator.
	Apeluri functie in MAIN
In main citim din parametrii liniei de comanda valoarea lui M (pe care trebuie sa il transformam in int, pentru ca era de tip char*) si numele fisierelor de input si output. Am declarat si 3 stringuri auxiliare in care salvam la citire: numele comenzii si valorile key respectiv value citite. Initializam tabela hash folosind functia InitTH si verificam daca alocarea este reusita. In caz afirmativ, citim din fisierul de input, pentru fiecare linie, numele primei comenzi si o apelam in mod corespunzator. La final, eliberam memoria si inchidem fisierele.